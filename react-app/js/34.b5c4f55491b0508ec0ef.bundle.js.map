{"version":3,"sources":["webpack:///./src/pages/2048/tools.tsx"],"names":["getValue","x","y","p","res","v","index","some","i","same","moveRight","changed","max","curr","occupied","currV","nextV","currIndex","merged","nextIndex","push","id","Math","random","moveLeft","min","moveDown","moveUp"],"mappings":"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","file":"js/34.b5c4f55491b0508ec0ef.bundle.js","sourcesContent":["interface IPiece {\n  x: number,\n  y: number,\n  v: number,\n  merged?: boolean,\n  id: number\n}\n\nconst getValue = (x, y, p) => {\n  let res = { v: 0, index: -1 }\n  p.some((i, index) => {\n    const same = i.x === x && i.y === y\n    if (same) { res = { v: i.v, index } }\n    return same\n  })\n  return res\n}\n\nexport default {\n  moveRight: (p: IPiece[]) => {\n    let changed = false\n    for (let y = 0; y < 4; y++) {\n      let max = 3\n      for (let x = 2; x >= 0; x--) {\n        let curr = -1\n        const isOccupied = p.some((i, index) => {\n          const occupied = i.x === (x + 1) && i.y === y\n          if (i.x === x && i.y === y) { curr = index }\n          if (occupied) { max-- }\n          return occupied\n        })\n        if (!isOccupied && curr >= 0) {\n          p[curr].x = max\n          changed = true\n          max--\n        }\n      }\n      for (let x = 2; x >= 0; x--) {\n        const { v: currV, index: currIndex } = getValue(x, y, p)\n        const { v: nextV, index: nextIndex } = getValue(x + 1, y, p)\n        if (currV && nextV && currV === nextV) {\n          p[currIndex].x = x + 1\n          p[currIndex].merged = true\n          p[nextIndex].merged = true\n          for (let v = x - 1; v >= 0; v--) {\n            const { index: i } = getValue(v, y, p)\n            if (i >= 0) { p[i].x = p[i].x < 3 ? p[i].x + 1 : p[i].x }\n          }\n          p.push({ x: x + 1, y, v: currV * 2, id: Math.random() })\n          changed = true\n        }\n      }\n    }\n    return { p, changed }\n  },\n\n  moveLeft: (p: IPiece[]) => {\n    let changed = false\n    for (let y = 0; y < 4; y++) {\n      let min = 0\n      for (let x = 1; x < 4; x++) {\n        let curr = -1\n        const isOccupied = p.some((i, index) => {\n          const occupied = i.x === (x - 1) && i.y === y\n          if (i.x === x && i.y === y) { curr = index }\n          if (occupied) { min++ }\n          return occupied\n        })\n        if (!isOccupied && curr >= 0) {\n          p[curr].x = min\n          changed = true\n          min++\n        }\n      }\n      for (let x = 1; x < 4; x++) {\n        const { v: currV, index: currIndex } = getValue(x, y, p)\n        const { v: nextV, index: nextIndex } = getValue(x - 1, y, p)\n        if (currV && nextV && currV === nextV) {\n          p[currIndex].x = x - 1\n          p[currIndex].merged = true\n          p[nextIndex].merged = true\n          for (let v = x; v <= 3; v++) {\n            const { index: i } = getValue(v, y, p)\n            if (i >= 0) { p[i].x = p[i].x > 0 ? p[i].x - 1 : p[i].x }\n          }\n          p.push({ x: x - 1, y, v: currV * 2, id: Math.random() })\n          changed = true\n        }\n      }\n    }\n    return { p, changed }\n  },\n\n  moveDown: (p: IPiece[]) => {\n    let changed = false\n    for (let x = 0; x < 4; x++) {\n      let max = 3\n      for (let y = 2; y >= 0; y--) {\n        let curr = -1\n        const isOccupied = p.some((i, index) => {\n          const occupied = i.x === x && i.y === (y + 1)\n          if (i.x === x && i.y === y) { curr = index }\n          if (occupied) { max-- }\n          return occupied\n        })\n        if (!isOccupied && curr >= 0) {\n          p[curr].y = max\n          changed = true\n          max--\n        }\n      }\n      for (let y = 2; y >= 0; y--) {\n        const { v: currV, index: currIndex } = getValue(x, y, p)\n        const { v: nextV, index: nextIndex } = getValue(x, y + 1, p)\n        if (currV && nextV && currV === nextV) {\n          p[currIndex].y = y + 1\n          p[currIndex].merged = true\n          p[nextIndex].merged = true\n          for (let v = y - 1; v >= 0; v--) {\n            const { index: i } = getValue(x, v, p)\n            if (i >= 0) { p[i].y = p[i].y < 3 ? p[i].y + 1 : p[i].y }\n          }\n          p.push({ x, y: y + 1, v: currV * 2, id: Math.random() })\n          changed = true\n        }\n      }\n    }\n    return { p, changed }\n  },\n\n  moveUp: (p: IPiece[]) => {\n    let changed = false\n    for (let x = 0; x < 4; x++) {\n      let min = 0\n      for (let y = 1; y < 4; y++) {\n        let curr = -1\n        const isOccupied = p.some((i, index) => {\n          const occupied = i.x === x && i.y === (y - 1)\n          if (i.x === x && i.y === y) { curr = index }\n          if (occupied) { min++ }\n          return occupied\n        })\n        if (!isOccupied && curr >= 0) {\n          p[curr].y = min\n          changed = true\n          min++\n        }\n      }\n      for (let y = 1; y < 4; y++) {\n        const { v: currV, index: currIndex } = getValue(x, y, p)\n        const { v: nextV, index: nextIndex } = getValue(x, y - 1, p)\n        if (currV && nextV && currV === nextV) {\n          p[currIndex].y = y - 1\n          p[currIndex].merged = true\n          p[nextIndex].merged = true\n          for (let v = y; v <= 3; v++) {\n            const { index: i } = getValue(x, v, p)\n            if (i >= 0) { p[i].y = p[i].y > 0 ? p[i].y - 1 : p[i].y }\n          }\n          p.push({ x, y: y - 1, v: currV * 2, id: Math.random() })\n          changed = true\n        }\n      }\n    }\n    return { p, changed }\n  }\n}\n"],"sourceRoot":""}